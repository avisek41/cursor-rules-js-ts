---
description: Core code quality standards — SOLID, DRY, KISS, YAGNI, error handling, security, input validation, and performance. Always active for all TypeScript/JavaScript projects.
alwaysApply: true
---

# Code Quality Standards

Applies to all TypeScript/JavaScript projects: React, Angular, Node.js, React Native.

---

## Core Principles

### SOLID
- **S** — Single Responsibility: one class/function, one reason to change
- **O** — Open/Closed: open for extension, closed for modification
- **L** — Liskov Substitution: subtypes must be substitutable for their base types
- **I** — Interface Segregation: many specific interfaces > one general interface
- **D** — Dependency Inversion: depend on abstractions, not concretions

### DRY / KISS / YAGNI
- Extract repeated logic after the third occurrence ("Rule of Three")
- Simple solution > clever solution; readable code > smart code
- Build what you need now — remove unused code immediately

### JS/TS-Specific Principles

| Principle | Rule |
|-----------|------|
| **Composition over inheritance** | Prefer hooks/modules over deep class hierarchies |
| **Immutability** | `const` by default; spread/map/filter over mutation |
| **Explicit over implicit** | Clear types, no magic, obvious control flow |
| **Pure functions** | Same input → same output; isolate side effects at boundaries |
| **Single source of truth** | One canonical place per piece of state |
| **Least surprise** | APIs should behave exactly as a reasonable dev expects |
| **Encapsulation** | Small, stable public surface; hide implementation details |

---

## Code Structure

### Size Limits
- **Functions**: max 50 lines (aim for 20–30); one function = one responsibility
- **Files**: max 300–500 lines; split when larger
- **Nesting**: max 3 levels deep — use early returns to flatten

```typescript
// ✅ Early return (flat)
function processUser(user: User | null): ProcessedUser | null {
  if (!user) return null;
  if (!user.active) return null;
  if (!user.hasPermission) return null;
  return processActiveUser(user);
}

// ❌ Deep nesting
function processUser(user: User | null) {
  if (user) {
    if (user.active) {
      if (user.hasPermission) { /* buried logic */ }
    }
  }
}
```

### Cyclomatic Complexity
- Max 10 per function — reduce via early returns, extracted helpers, or lookup tables

### Import Organization
```typescript
// 1. Node built-ins
import { readFile } from 'node:fs/promises';
// 2. External packages
import { z } from 'zod';
// 3. Internal absolute (@/)
import { UserService } from '@/services/user-service';
// 4. Relative
import { formatDate } from '../utils/date';
// 5. Type-only imports last (or co-located above, always import type)
import type { UserDto } from './types';
```

---

## Error Handling

### Never Fail Silently

```typescript
// ❌ Swallows the error
try {
  await riskyOperation();
} catch (_err) {}

// ✅ Handle or propagate
try {
  await riskyOperation();
} catch (error) {
  logger.error('riskyOperation failed', { error, context });
  throw new AppError('Operation failed', 'OPERATION_FAILED', 500);
}
```

### Custom Error Hierarchy

```typescript
class AppError extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly statusCode: number = 500,
  ) {
    super(message);
    this.name = 'AppError';
  }
}

class NotFoundError extends AppError {
  constructor(resource: string, id: string) {
    super(`${resource} with id "${id}" not found`, 'NOT_FOUND', 404);
  }
}

class ValidationError extends AppError {
  constructor(message: string) {
    super(message, 'VALIDATION_ERROR', 400);
  }
}
```

### Result Type — For Expected Failures

```typescript
// Use for operations that can predictably fail (parsing, validation, external calls)
// Use throw/try-catch for unexpected/exceptional failures
type Result<T, E = AppError> =
  | { ok: true; value: T }
  | { ok: false; error: E };

async function parseUserPayload(raw: unknown): Promise<Result<User>> {
  const parsed = UserSchema.safeParse(raw);
  if (!parsed.success) {
    return { ok: false, error: new ValidationError(parsed.error.message) };
  }
  return { ok: true, value: parsed.data };
}
```

### Fail Fast
- Validate inputs at function/module boundaries — never let invalid data propagate
- Use Zod (or equivalent) for runtime validation at I/O boundaries (API, env, external data)

---

## Magic Values — Never

```typescript
// ❌
if (user.age > 18) { }
setTimeout(fn, 5000);

// ✅
const ADULT_AGE_YEARS = 18;
const SESSION_TIMEOUT_MS = 5_000;
if (user.age > ADULT_AGE_YEARS) { }
setTimeout(fn, SESSION_TIMEOUT_MS);
```

---

## Function Parameters

```typescript
// ❌ Too many positional params
function createUser(name: string, email: string, age: number, role: string, dept: string) {}

// ✅ Config object — named, extensible, order-independent
interface CreateUserParams {
  name: string;
  email: string;
  age: number;
  role: string;
  department: string;
}
function createUser({ name, email, age, role, department }: CreateUserParams) {}
```

Max 3–4 positional params; use a config object beyond that.

---

## Security Checklist
- Never hardcode secrets, API keys, or credentials — use environment variables
- Validate and sanitize all user inputs (never trust the client)
- Use parameterized queries — never string-concatenate SQL/queries
- Implement proper authentication and authorization checks
- Principle of least privilege for all service accounts and roles
- Keep dependencies updated (`npm audit` in CI)

---

## Performance — Profile First
- Write clean, readable code first; optimize only when metrics justify it
- Avoid unnecessary computations inside loops
- Minimize database queries and API calls (batch, cache, paginate)
- Use lazy loading / code splitting at route/feature boundaries
- Profile before adding `useMemo`, `useCallback`, or caching — they add complexity

---

## Code Smells to Eliminate

| Smell | Signal | Fix |
|-------|--------|-----|
| Long parameter lists | > 4 params | Config object |
| Feature envy | Function accesses another module's data more than its own | Move logic to where data lives |
| Data clumps | Same vars always appear together | Create a type/object |
| Shotgun surgery | One change requires editing many files | Consolidate |
| Dead code | Commented-out or unreachable code | Delete it (git has history) |
| God object | One class/file does everything | Split by responsibility |

---

## Code Review Checklist

Before submitting a PR, verify:

- [ ] Functions ≤ 50 lines, files ≤ 500 lines
- [ ] No magic numbers or strings — all named constants
- [ ] Errors handled (never silent), specific messages
- [ ] Input validation at boundaries
- [ ] No duplicated logic (Rule of Three applied)
- [ ] No unused imports, variables, or dead code
- [ ] No stray `console.log` — use structured logger
- [ ] No hardcoded config or secrets
- [ ] TypeScript: no `any`, explicit types on public APIs
- [ ] Tests included for new logic
- [ ] No unrelated legacy code refactored in same PR
